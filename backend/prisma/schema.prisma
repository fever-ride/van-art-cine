generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // relationMode = "prisma"
}

model app_user {
  uid                 BigInt                @id @default(autoincrement()) @db.BigInt
  name                String                @db.VarChar(100)
  email               String                @unique @db.VarChar(255)
  password_hash       String                @db.VarChar(255)
  role                app_user_role         @default(user)
  created_at          DateTime              @default(now()) @db.Timestamp(0)
  custom_event        custom_event[]
  refresh_token       refresh_token[]
  user_schedule       user_schedule[]
  watchlist_screening watchlist_screening[]
}

model cinema {
  id            Int             @id @default(autoincrement())
  name          String          @unique @db.VarChar(120)
  website       String?         @db.VarChar(255)
  address       String?         @db.VarChar(300)
  created_at    DateTime?       @default(now()) @db.Timestamp(0)
  raw_import    raw_import[]
  screening     screening[]
  stg_screening stg_screening[]
}

model custom_event {
  id         BigInt    @id @default(autoincrement()) @db.BigInt
  user_uid   BigInt    @db.BigInt
  event_name String    @db.VarChar(255)
  event_data Json?
  created_at DateTime? @default(now()) @db.Timestamp(0)
  app_user   app_user  @relation(fields: [user_uid], references: [uid], onDelete: Cascade)

  @@index([user_uid])
}

model film {
  id               Int             @id @default(autoincrement())
  title            String          @db.VarChar(255)
  year             Int?            @db.SmallInt
  rated            String?         @db.VarChar(16)
  genre            String?         @db.VarChar(255)
  language         String?         @db.VarChar(255)
  country          String?         @db.VarChar(255)
  awards           String?         @db.VarChar(255)
  rt_rating_pct    Int?            @db.SmallInt
  imdb_rating      Decimal?        @db.Decimal(3, 1)
  imdb_votes       Int?            @db.Integer
  description      String?         @db.Text
  normalized_title String?         @db.VarChar(255)
  imdb_id          String?         @db.VarChar(16)
  tmdb_id          Int?
  imdb_url         String?         @db.VarChar(512)
  tags             String[]        @db.Text
  created_at       DateTime?       @default(now()) @db.Timestamp(0)
  film_person      film_person[]
  screening        screening[]
  stg_screening    stg_screening[]

  @@unique([normalized_title, year])
}

model film_person {
  film_id    Int
  person_id  Int
  role       film_person_role @default(unknown)
  created_at DateTime?        @default(now()) @db.Timestamp(0)
  film       film             @relation(fields: [film_id], references: [id])
  person     person           @relation(fields: [person_id], references: [id])

  @@id([film_id, person_id, role])
  @@index([person_id])
}

model ops_ingest_run {
  id               BigInt                @id @default(autoincrement())
  started_at       DateTime              @db.Timestamp(0)
  finished_at      DateTime?             @db.Timestamp(0)
  rows_in          Int                   @default(0)
  rows_inserted    Int                   @default(0)
  rows_updated     Int                   @default(0)
  rows_deactivated Int                   @default(0)
  status           ops_ingest_run_status @default(running)
  message          String?               @db.VarChar(500)
  screening        screening[]

  @@index([started_at])
}

model person {
  id              Int           @id @default(autoincrement())
  name            String        @db.VarChar(160)
  imdb_id         String?       @db.VarChar(16)
  tmdb_id         Int?
  normalized_name String        @unique @db.VarChar(160)
  created_at      DateTime?     @default(now()) @db.Timestamp(0)
  film_person     film_person[]
}

model raw_import {
  id             Int      @id @default(autoincrement())
  cinema_id      Int
  source         String   @db.VarChar(32)
  fetched_at     DateTime @db.Timestamp(0)
  payload        Json
  rows_processed Int?     @default(0)
  cinema         cinema   @relation(fields: [cinema_id], references: [id])

  @@index([cinema_id])
  @@index([cinema_id, fetched_at])
  @@index([fetched_at])
  @@index([source, fetched_at])
}

model refresh_token {
  id         BigInt    @id @default(autoincrement()) @db.BigInt
  user_id    BigInt    @db.BigInt
  token      String    @unique @db.Char(64)
  expires_at DateTime  @db.Timestamp(0)
  revoked_at DateTime? @db.Timestamp(0)
  user_agent String?   @db.VarChar(255)
  ip         String?   @db.VarChar(64)
  created_at DateTime  @default(now()) @db.Timestamp(0)
  app_user   app_user  @relation(fields: [user_id], references: [uid], onDelete: Cascade)

  @@index([user_id, revoked_at, expires_at])
  @@index([user_id])
}

/// source_uid:
/// - Generated during scraping based on the *original* scraped data.
/// - NOT a business-stable ID (film_id may change after merge_duplicate_films).
/// - screening uniqueness is guaranteed by (cinema_id, film_id, start_at_utc).
model screening {
  id                  Int                   @id @default(autoincrement())
  film_id             Int
  cinema_id           Int
  start_at_utc        DateTime              @db.Timestamp(0)
  end_at_utc          DateTime              @db.Timestamp(0)
  runtime_min         Int?                  @db.SmallInt
  tz                  String                @default("America/Vancouver") @db.VarChar(64)
  source              String                @default("manual") @db.VarChar(32)
  source_uid          String?               @db.VarChar(128)
  source_url          String                @db.VarChar(512)
  content_hash        String?               @db.Char(64)
  loaded_at_utc       DateTime              @db.Timestamp(0)
  ingest_run_id       BigInt?
  notes               String?               @db.VarChar(255)
  raw_date            String?               @db.VarChar(80)
  raw_time            String?               @db.VarChar(80)
  is_active           Boolean               @default(true)
  tags                String[]              @db.Text
  created_at          DateTime              @default(now()) @db.Timestamp(0)
  updated_at          DateTime              @default(now()) @db.Timestamp(0)
  ops_ingest_run      ops_ingest_run?       @relation(fields: [ingest_run_id], references: [id])
  film                film                  @relation(fields: [film_id], references: [id])
  cinema              cinema                @relation(fields: [cinema_id], references: [id])
  watchlist_screening watchlist_screening[]

  @@unique([cinema_id, film_id, start_at_utc])
  @@unique([source, source_uid])
  @@index([ingest_run_id])
  @@index([is_active, source])
  @@index([cinema_id])
  @@index([film_id])
  @@index([start_at_utc])
}

/// source_uid: primary key for staging rows.
/// - Ensures each scraped screening is uniquely stored for a given (source, source_uid).
/// - Allows staging to be loaded safely without duplicates.
/// - This ID is not stable across film merges; only staging-level identity.
model stg_screening {
  film_id       Int
  cinema_id     Int
  start_at_utc  DateTime  @db.Timestamp(0)
  end_at_utc    DateTime  @db.Timestamp(0)
  runtime_min   Int?      @db.SmallInt
  tz            String    @default("America/Vancouver") @db.VarChar(64)
  source        String    @db.VarChar(32)
  source_uid    String    @db.VarChar(128)
  source_url    String    @db.VarChar(512)
  notes         String?   @db.VarChar(255)
  raw_date      String?   @db.VarChar(80)
  raw_time      String?   @db.VarChar(80)
  content_hash  String    @db.Char(64)
  loaded_at_utc DateTime  @db.Timestamp(0)
  loaded_at     DateTime? @default(now()) @db.Timestamp(0)
  tags          String[]  @db.Text

  film          film      @relation(fields: [film_id], references: [id])
  cinema        cinema    @relation(fields: [cinema_id], references: [id])

  @@id([source, source_uid]) 
  @@index([cinema_id])
  @@index([film_id])
  @@index([start_at_utc])
  @@index([source, source_uid])
}

// This table is not used in current version.
model user_schedule {
  id            BigInt    @id @default(autoincrement()) @db.BigInt
  user_uid      BigInt    @db.BigInt
  schedule_data Json
  created_at    DateTime? @default(now()) @db.Timestamp(0)
  app_user      app_user  @relation(fields: [user_uid], references: [uid], onDelete: Cascade)

  @@index([user_uid])
}

model watchlist_screening {
  id           BigInt                     @id @default(autoincrement()) @db.BigInt
  user_uid     BigInt                     @db.BigInt
  screening_id Int
  status       watchlist_screening_status @default(planned)
  note         String?                    @db.VarChar(500)
  created_at   DateTime                   @default(now()) @db.Timestamp(0)
  updated_at   DateTime                   @default(now()) @db.Timestamp(0)
  screening    screening                  @relation(fields: [screening_id], references: [id], onDelete: Cascade)
  app_user     app_user                   @relation(fields: [user_uid], references: [uid], onDelete: Cascade)

  @@unique([user_uid, screening_id])
  @@index([screening_id])
  @@index([user_uid])
}

enum film_person_role {
  director
  writer
  cast
  unknown
}

enum watchlist_screening_status {
  planned
  watched
}

enum app_user_role {
  user
  admin
}

enum ops_ingest_run_status {
  running
  success
  error
}
